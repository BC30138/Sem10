# Лекция №1. 13.02.2019
## Java Memory Model.

Модель памяти - способ доступа к памяти, а именно как система (параллельная или последовательная) работает с ней.

Java Concurrency in Practice - очень понятная книга.

JSR 133 - стандарт организации модели памяти. 

Зачем нужен стандарт:
- Чтобы программист понимал как устроена память, что можно делать, а что нет.

Бывает два типа моделей памяти: 
1. Сильная модель памяти.

    все процессоры всегда видят одинаковые значения для любой заданной ячейки памяти.

2. Слабая модель памяти.

    требуются специальные инструкции - барьеры памяти, требуются для сброса или объявления недействительными данных в ячейке.

ccNUMA - память общая для процессоров, но доступ к памяти зависит от расположения памяти (на работающем ядре, на сокете в другом ядре, в ядре на другом сокете), при этом когерентность обеспечивается аппаратно. тип памяти поддерживает ОС Linux, используя библиотеки libnuma, afinity (не допускает "переезда" потока на другое ядро, в случае чего память станет нелокальной).

Видимость - если поток работает с данными и выгрузил значения полей к себе в локальную память, после чего изменил значения полей, то другой поток может не увидеть изменений.

Reordering - для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции/операции, что может привести к к проблемам: 

```cpp
//first thread
result = calc(); //    если переставить местами эти две строки 
resultReady = true; // получится ошибка

//second thread
if (resultReady) takeDesision(result);
```

Happens before - в JMM введена данная абстракция. Она означает, что если операция X связана отношением happens-before с Y, то обязательно выполнится сначала X, потом Y. (Используются мониторы)

В лекции приведен список операций happens-before, который необходимо понять для хорошего параллельного программирования. 