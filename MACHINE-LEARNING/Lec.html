<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style>@font-face {
  font-family: octicons-anchor;
  src: url(https://cdnjs.cloudflare.com/ajax/libs/octicons/4.4.0/font/octicons.woff) format('woff');
}

* {
    box-sizing: border-box;
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
    color:#333;
    background:#fff;
}

body .markdown-body {
    padding: 45px;
    border: 1px solid #ddd;
    border-radius: 3px;
    word-wrap: break-word;
}

pre {
    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body {
  -webkit-text-size-adjust: 100%;
  text-size-adjust: 100%;
  color: #333;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body strong {
  font-weight: bold;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body input {
  font: 13px / 1.4 Helvetica, arial, nimbussansl, liberationsans, freesans, clean, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
}

.markdown-body a {
  color: #4078c0;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before {
  display: table;
  content: "";
}

.markdown-body hr:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
  font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;
}

.markdown-body .select::-ms-expand {
  opacity: 0;
}

.markdown-body .octicon {
  font: normal normal normal 16px/1 octicons-anchor;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.markdown-body .octicon-link:before {
  content: '\f05c';
}

.markdown-body:before {
  display: table;
  content: "";
}

.markdown-body:after {
  display: table;
  clear: both;
  content: "";
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body .anchor {
  display: inline-block;
  padding-right: 2px;
  margin-left: -18px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 1em;
  margin-bottom: 16px;
  font-weight: bold;
  line-height: 1.4;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #000;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h1 .anchor {
  line-height: 1;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 .anchor {
  line-height: 1;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h3 .anchor {
  line-height: 1.2;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h4 .anchor {
  line-height: 1.2;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h5 .anchor {
  line-height: 1.1;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body h6 .anchor {
  line-height: 1.1;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  box-sizing: content-box;
  background-color: #fff;
}

.markdown-body code {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font-size: 11px;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .pl-c {
  color: #969896;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #0086b3;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #795da3;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #333;
}

.markdown-body .pl-ent {
  color: #63a35c;
}

.markdown-body .pl-k {
  color: #a71d5d;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #183691;
}

.markdown-body .pl-v {
  color: #ed6a43;
}

.markdown-body .pl-id {
  color: #b52a1d;
}

.markdown-body .pl-ii {
  background-color: #b52a1d;
  color: #f8f8f8;
}

.markdown-body .pl-sr .pl-cce {
  color: #63a35c;
  font-weight: bold;
}

.markdown-body .pl-ml {
  color: #693a17;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #1d3e81;
  font-weight: bold;
}

.markdown-body .pl-mq {
  color: #008080;
}

.markdown-body .pl-mi {
  color: #333;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #333;
  font-weight: bold;
}

.markdown-body .pl-md {
  background-color: #ffecec;
  color: #bd2c00;
}

.markdown-body .pl-mi1 {
  background-color: #eaffea;
  color: #55a532;
}

.markdown-body .pl-mdr {
  color: #795da3;
  font-weight: bold;
}

.markdown-body .pl-mo {
  color: #1d3e81;
}

.markdown-body kbd {
  display: inline-block;
  padding: 3px 5px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  line-height: 10px;
  color: #555;
  vertical-align: middle;
  background-color: #fcfcfc;
  border: solid 1px #ccc;
  border-bottom-color: #bbb;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #bbb;
}

.markdown-body .plan-price-unit {
  color: #767676;
  font-weight: normal;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 0.35em 0.25em -1.6em;
  vertical-align: middle;
}

.markdown-body .plan-choice {
  padding: 15px;
  padding-left: 40px;
  display: block;
  border: 1px solid #e0e0e0;
  position: relative;
  font-weight: normal;
  background-color: #fafafa;
}

.markdown-body .plan-choice.open {
  background-color: #fff;
}

.markdown-body .plan-choice.open .plan-choice-seat-breakdown {
  display: block;
}

.markdown-body .plan-choice-free {
  border-radius: 3px 3px 0 0;
}

.markdown-body .plan-choice-paid {
  border-radius: 0 0 3px 3px;
  border-top: 0;
  margin-bottom: 20px;
}

.markdown-body .plan-choice-radio {
  position: absolute;
  left: 15px;
  top: 18px;
}

.markdown-body .plan-choice-exp {
  color: #999;
  font-size: 12px;
  margin-top: 5px;
}

.markdown-body .plan-choice-seat-breakdown {
  margin-top: 10px;
  display: none;
}

.markdown-body :checked+.radio-label {
  z-index: 1;
  position: relative;
  border-color: #4078c0;
}

@media print {
  body .markdown-body {
    padding: 0;
    border: none;
  }
}
</style><title>Lec</title></head><body><article class="markdown-body"><hr>
<p>title: Машинное обучение
author:</p>
<ul>
<li>Уткин Лев Владимирович.
date: 2019</li>
</ul>
<hr>
<h1>
<a id="user-content-лекция-1-12022019" class="anchor" href="#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-1-12022019" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Лекция №1. 12.02.2019</h1>
<h2>
<a id="user-content-сверточные-сети" class="anchor" href="#%D1%81%D0%B2%D0%B5%D1%80%D1%82%D0%BE%D1%87%D0%BD%D1%8B%D0%B5-%D1%81%D0%B5%D1%82%D0%B8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Сверточные сети.</h2>
<p><strong>Вход</strong> - большой размерности: каждый нейрон имеет огромное число соединений. Малая картинка 100x100 пикселей (размерность входа 10000), каждый нейрон имеет 10000 параметров. Если скрытый слой - 2000 нейронов, то всего 2 х $10^7$ соединений.</p>
<p>$$
f(w,x) \rightarrow y \in {1,2,3,4}
$$</p>
<p>x - вектор характеризующий параметры.</p>
<p>w - вектор весов (соединений).</p>
<p>Скрытый слой содержит больше нейронов, чем изначальный.</p>
<p>Чтобы научить каждый вес требуется 3 - 5 изображений (при том картинки размеченные, то есть уже разбиты на классы, например "кошки", "собаки").</p>
<p><strong>То есть требуется действительно большое количество картинок для обучения большой сетки.</strong></p>
<p><em>а что, если часть соединений убрать?</em></p>
<p>ЛеКун в 1995 предложил устроить все по аналогии работы глаза. Обрабатывать не все изображение, а отдельные "квадраты".</p>
<p>Как уменьшить число соединений?</p>
<ul>
<li>Сделать часть весов одинаковыми ("weight sharing" или <strong>свертка</strong>)</li>
<li>w1 = w4 = w7, w2 = w5 = w8, w3 = w6 = w9</li>
<li>вместо хранения всех весов, храним w1 w2 w3</li>
</ul>
<p>Вход
$\Rightarrow$
Свертка
$\Rightarrow$
Пулинг (subsampling)
$\Rightarrow$
Свертка
$\Rightarrow$
Пулинг
$\Rightarrow$
...
$\Rightarrow$
Свертка
$\Rightarrow$
Пулинг
$\Rightarrow$
Выход</p>
<p>Сверточный слой - реализует обычную операцию свертки, двигаясь по изображению скользящим окном.</p>
<p>Пулинговый слой - сжатие данных для достижения меньшей размерности.</p>
<p>$$
\sum w_{ij} a_{ij}
$$</p>
<p>$а_{ij}$ - элементы ядра входного слоя (значение квадратов пикселей на входном изображении). А - матрица.</p>
<p>$w_{ij}$ - элементы ядра сверточного слоя. W - матрица.</p>
<h2>
<a id="user-content-max-pooling" class="anchor" href="#max-pooling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Max-pooling</h2>
<p>получено изображение от сверточного слоя. Разбиваем опять сеткой это изображение и строим новое, основываясь на максимальном значении в окне сетки.</p>
<p>Были значения на иображении:</p>
<pre><code>0.0   0.0   0.0   0.0 
0.0   0.0   0.0   0.5
0.0   0.0   0.5   1.0
1.0   0.5   0.0   0.0
</code></pre>
<p>Разбиваем:</p>
<pre><code>0.0   0.0   |  0.0   0.0 
0.0   0.0   |  0.0   0.5
________________________
0.0   0.0   |  0.5   1.0
1.0   0.5   |  0.0   0.0
</code></pre>
<p>Производим Max-pooling:</p>
<pre><code>0   0.5
1   1
</code></pre>
<p>AVE (Average-pooling) - тоже самое только рассматриваются средние значения.</p>

<h1>
<a id="user-content-лекция-2-260219" class="anchor" href="#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-2-260219" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Лекция 2 26.02.19</h1>
<p>Преимущества сверточных сетей:</p>
<ul>
<li>один из лучших для распознания и классификации</li>
<li>меньшее количество весов по сравнению с нейронной сетью</li>
<li>обобщает информацию, а не попикселльно запоминает каждую картинку в коэффициентах. (спорное утверждение)</li>
<li>распараллеливание, возможно реализация на ГПУ.</li>
<li>устойчивость к деформации изображения (поворот, сдвиг)</li>
<li>обучение при помощи классического метода обратного распространения ошибки</li>
</ul>
<p>Недостатки сверточных сетей:</p>
<ul>
<li>По большей части архитектура для распознавания изображений</li>
<li>Слишком много варьируемых параметров. А обучение итак слишком долгое, поэтому обучение слишком затруднено, когда существует большое множество вариантов параметров.</li>
</ul>
<h2>
<a id="user-content-7-приемов-для-более-эффективного-обучения-нс" class="anchor" href="#7-%D0%BF%D1%80%D0%B8%D0%B5%D0%BC%D0%BE%D0%B2-%D0%B4%D0%BB%D1%8F-%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5-%D1%8D%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BE%D0%B1%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D1%8F-%D0%BD%D1%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>7 приемов для более эффективного обучения НС</h2>
<p>Напомним:</p>
<ul>
<li>
<p>Требуется определить параметры НС, такие как выборки, скорость и т.д.;</p>
</li>
<li>
<p>Нет четких правил дл выбора</p>
</li>
<li>
<ol>
<li>Обучение - минимизировать функцию потерь.</li>
<li>Обобщение - прогнозирование на новых примерах.</li>
</ol>
<p>Требуется найти компромисс между обучением и обобщением.</p>
</li>
<li>
<p>Для хорошего обучения требуется оценивать качество обучения, мы можем это сделать с помощью:</p>
<ol>
<li>Смещение - требуется сделать так, чтобы данные имели разброс ближе либо к 0 либо к 1</li>
<li>Дисперсия - мера того, насколько выход НС варьируется для разных данных. Дисперсия должна быть как можно более меньшей.</li>
</ol>
</li>
</ul>
<p>Чем дольше мы обучаем тем большая дисперсия, но малое смещение. И наоборот, соответственно. Это происходит потому что НС начинает учиться на шуме.</p>
<h3>
<a id="user-content-прием-1-stochastic-versus-batch-learning" class="anchor" href="#%D0%BF%D1%80%D0%B8%D0%B5%D0%BC-1-stochastic-versus-batch-learning" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Прием №1 Stochastic Versus Batch Learning</h3>
<p>Градиентный спуск и обратное распространение ошибки заключается в том, что если есть сетка (не важно сверточная или нет) с весами $w_1$ ... $w_n$, а на вход подаем вектор $x_1$ ... $x_n$ и вычисляется $S = y^{*} - y$ для каждого x. (что-то пропустил, думаю надо будет погуглить)</p>
<ul>
<li>Стохастический градиентный спуск - из обучающей выборки выбирается один элемент на каждой итерации.</li>
<li>Пакетный - просматривается и модифицируется вся сетка.</li>
</ul>
<p>Stochastic Learning и Mini-Batch</p>
<ul>
<li>Обычно намного быстрее, чем пакетное обучение;</li>
<li>Часто приводит к лучшим решениям;</li>
<li>Может быть использовано для отслеживания изменений</li>
</ul>
<p>Но шум все может испортить</p>
<p>=&gt; Mini-Batch что-то там и если этот параметр больше то хуже.</p>
<h3>
<a id="user-content-прием-2-shuffling-the-examples-перемешивание" class="anchor" href="#%D0%BF%D1%80%D0%B8%D0%B5%D0%BC-2-shuffling-the-examples-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D1%88%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Прием №2 Shuffling the Examples (Перемешивание)</h3>
<p>НС обучается быстрее на наиболее неожиданных примерах.</p>
<p>С точки зрения градиента - неожиданный пример портит картину. И это работает как мутация. То есть можно ускорить обучение с помощью перемешивания выборов из разных классов. Возможен вариант алгоритм, когда выбор каждого объекта неравновероятен, причем вероятность выпадения объекта обратно пропорциональна величине ошибки на объекте.</p>
<h3>
<a id="user-content-прием-3-normalizing-the-inputs-нормализация" class="anchor" href="#%D0%BF%D1%80%D0%B8%D0%B5%D0%BC-3-normalizing-the-inputs-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Прием №3 Normalizing the Inputs (нормализация)</h3>
<p>Было замечено, что среднее значение каждой входной из обучающей выборки ближе нулю, то обучение проходит лучше. То есть требуется для обучающей выборки сделать мат.ожидание 0. То есть лучше вычислить сначала среднее, а потом вычесть из каждого входного данного полученное значение.</p>
<p>Масштабирование ускоряет обучение. Вычислим среднеквадратичное отклонение $\sigma = \frac{1}{n}\sum(x_{i} - x_{ave})^2$.</p>
<p>$x_{i}^{*}\leftarrow \frac{x_{i} - x_{ave}}{\sqrt{\sigma^{2} + \epsilon}}$</p>
<p>также производится декореляция.</p>
<h3>
<a id="user-content-прием-4-sigmoid" class="anchor" href="#%D0%BF%D1%80%D0%B8%D0%B5%D0%BC-4-sigmoid" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Прием №4 Sigmoid</h3>
<p>(существуют сигмоиды, бисигмоиды и релу (проблема релу - чем более функция активации линейна, тем сложнее достигнуть нелинейности).)</p>
<p>Симметричные сигмоиды часто сходятся быстрее, чем стандартная логистическая функция.</p>
<h3>
<a id="user-content-прием-5-choosing-target-values" class="anchor" href="#%D0%BF%D1%80%D0%B8%D0%B5%D0%BC-5-choosing-target-values" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Прием №5 Choosing Target Values</h3>
<ul>
<li>Что выбрать {-1,1} или {0,1}?</li>
<li>Нужно брать целевые значения - в точке максимальной второй производной на сигмоиде (например {0.1,0.9} вместо {0,1}).</li>
</ul>
<h3>
<a id="user-content-пример-6-initializing-the-weights" class="anchor" href="#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-6-initializing-the-weights" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Пример №6 Initializing the Weights</h3>
<p>Веса должны выбираться так, чтобы сигмоид активировался в линейной области. Тоже самое и для ReLu.</p>
<h3>
<a id="user-content-пример-7-choosing-learning-rates" class="anchor" href="#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-7-choosing-learning-rates" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Пример №7 Choosing Learning Rates</h3>
<ul>
<li>Уменьшают скорость обучения когда весовой вектор "колеблется", и увеличивают, когда он устойчив.</li>
<li>Различная скорость обучения для каждого веса может улучшить сходимость.</li>
<li>скорость обучения должна быть пропорциональна квадратному корню из числа входов в нейрон.</li>
<li>Веса в нижних слоях обычно должны быть больше, чем в более высоких слоях.</li>
</ul>
<h1>
<a id="user-content-лекция-3-50319" class="anchor" href="#%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D1%8F-3-50319" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Лекция 3 5.03.19</h1>
<h2>
<a id="user-content-сегментация-изображений" class="anchor" href="#%D1%81%D0%B5%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D0%B8%D1%8F-%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Сегментация изображений</h2>
<p>Хорошим подходом является добавление дополнительного шага в алгоритм распознания изображений перед классификацией объекта. Этот шаг - сегментация. По-сути идея такая - выделить сначала сегменты изображения которые нас интересуют, а потом уже классифицировать объекты в сегментах.</p>
</article></body></html>